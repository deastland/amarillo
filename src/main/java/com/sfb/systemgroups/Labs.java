package com.sfb.systemgroups;

import java.util.Map;

import com.sfb.objects.Marker;
import com.sfb.objects.Unit;
import com.sfb.utilities.DiceRoller;
import com.sfb.utilities.MapUtils;

public class Labs implements Systems {
	
	// Used to determine the amount of scientific data gathered by each lab
	// box based on closest approach to the target and a die roll.
	private int[][] labScienceGrid = {
			// Range 0-10
			{10,9,8,7,6,5,4,3,2,1,0},	// Roll 1
			{9,8,7,6,5,4,3,2,1,0,0},	// Roll 2
			{8,7,6,5,4,3,2,1,0,0,0},	// Roll 3
			{7,6,5,4,3,2,1,0,0,0,0},	// Roll 4
			{6,5,4,3,2,1,0,0,0,0,0},	// Roll 5
			{5,4,3,2,1,0,0,0,0,0,0},	// Roll 6
	};

	private int lab;
	
	private int availableLab;
	
	private Unit owningUnit;
	
	//TODO: Lab functions (science and drone ID)
	
	public Labs(Unit owner) {
		this.owningUnit = owner;
	}
	
	// Initialize the operations systems to the SSD values.
	@Override
	public void init(Map<String, Object> values) {
		availableLab     = lab     = values.get("lab")     == null ? 0 : (Integer)values.get("lab");
	}
	
	/// FETCH ///
	public int getAvailableLab() {
		return availableLab;
	}
	
	// Total operations boxes on the SSD (cripple calculations).
	@Override
	public int fetchOriginalTotalBoxes() {
		return lab;
	}
	
	// Total current operations boxes (cripple calculations).
	@Override
	public int fetchRemainingTotalBoxes() {
		return availableLab;
	}
	
	/// DAMAGE ///
	public boolean damage() {
		if (availableLab == 0) {
			return false;
		}
		
		availableLab--;
		return true;
	}
	
	/// REPAIR ///
	public boolean repair(int value) {
		if (availableLab + value > lab) {
			return false;
		}
		
		availableLab += value;
		return true;
	}

	@Override
	public void cleanUp() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Unit fetchOwningUnit() {
		return this.owningUnit;
	}
	
	/**
	 * Given a target, calculate the total research points for a ship during
	 * a given turn.
	 * @param target The target that is being targeted by the ship's labs.
	 * @return The total number of research points.
	 */
	public int calculateResearchPoints(Marker target) {
		int range = MapUtils.getRange(owningUnit, target);
		
		return calculateResearchPoints(range);
	}
	
	/**
	 * Given the range to a target, calculate the total research points 
	 * for a ship during a given turn.
	 * @param range The minimum range to the target achieved during the turn.
	 * @return The total number of research points.
	 */
	public int calculateResearchPoints(int range) {
		// Labs don't work beyond range 9.
		if (range > 9) {
			return 0;
		}
		
		// Roll the die.
		DiceRoller roller = new DiceRoller();
		int roll = roller.rollOneDie();

		// Calculate the research generated by a single lab box.
		int researchPerLab = labScienceGrid[roll - 1][range];
		
		// Each active lab will return this amount of points.
		return researchPerLab * availableLab;
	}
	
}
